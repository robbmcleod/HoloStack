% HOLOSTACK SOFTWARE LICENSE
% Robert A. McLeod
% 16 January 2014
%
% 1.	Preamble: This Agreement, signed on Jan 16, 2014 (hereinafter: Effective Date) governs the relationship between David Cooper, a private person, (hereinafter: Licensee) and Robert A. McLeod, a private person whose principal place of business is 45c quai du Drac, 38600 Fontaine, France, France (Hereinafter: Licensor). This Agreement sets the terms, rights, restrictions and obligations on using HoloStack (hereinafter: The Software) created and owned by Licensor, as detailed herein
% 2.	License Grant: Licensor hereby grants Licensee a Personal, Non-assignable & non-transferable, Non-commercial, Including the rights to create but not distribute derivative works, Non-exclusive license, all with accordance with the terms set forth and other legal restrictions set forth in 3rd party software used while running Software.
% 2.1.	Limited: Licensee may use Software for the purpose of:
% 2.1.1.	Running Software on Licensee’s Computer[s] and Server[s];
% 2.1.2.	Allowing 3rd Parties to run Software on Licensee’s Computers[s] and Server[s];
% 2.1.3.	Publishing Software’s output to Licensee and 3rd Parties;
% 2.1.4.	Distribute verbatim copies of Software’s output (including compiled binaries);
% 2.1.5.	Modify Software to suit Licensee’s needs and specifications.
% 2.2.	Binary Restricted: Licensee may sublicense Software as a part of a larger work containing more than Software, distributed solely in Object or Binary form under a personal, non-sublicensable, limited license. Such redistribution shall be limited to unlimited codebases.
% 2.3.	Non Assignable & Non-Transferable: Licensee may not assign or transfer his rights and duties under this license.
% 2.4.	Non-Commercial: Licensee may not use Software for commercial purposes. for the purpose of this license, commercial purposes means that a 3rd party has to pay in order to access Software or that the Website that runs Software is behind a paywall.
% 2.5.	Including the Right to Create Derivative Works: Licensee may create derivative works based on Software, including amending Software’s source code, modifying it, integrating it into a larger work or removing portions of Software, as long as no distribution of the derivative works is made
% 2.6.	With Attribution Requirements: Public works derived from the software should be refer to Robert A. McLeod, Michael Bergen, and Marek Malac, "Phase error and spatial resolution for off-axis electron hologram series," In press (2013).
% 3.	Term & Termination: The Term of this license shall be until terminated. Licensor may terminate this Agreement, including Licensee’s license in the case where Licensee :
% 3.1.	became insolvent or otherwise entered into any liquidation process; or
% 3.2.	exported The Software to any jurisdiction where licensor may not enforce his rights under this agreements in; or
% 3.3.	Licensee was in breach of any of this license's terms and conditions and such breach was not cured, immediately upon notification; or
% 3.4.	Licensee in breach of any of the terms of clause 2 to this license; or
% 3.5.	Licensee otherwise entered into any arrangement which caused Licensor to be unable to enforce his rights under this License.
% 4.	Payment: In consideration of the License granted under clause 2, Licensee shall pay Licensor a fee, via Credit-Card, PayPal or any other mean which Licensor may deem adequate. Failure to perform payment shall construe as material breach of this Agreement.
% 5.	Upgrades, Updates and Fixes: Licensor may provide Licensee, from time to time, with Upgrades, Updates or Fixes, as detailed herein and according to his sole discretion. Licensee hereby warrants to keep The Software up-to-date and install all relevant updates and fixes, and may, at his sole discretion, purchase upgrades, according to the rates set by Licensor. Licensor shall provide any update or Fix free of charge; however, nothing in this Agreement shall require Licensor to provide Updates or Fixes.
% 5.1.	Upgrades: for the purpose of this license, an Upgrade shall be a material amendment in The Software, which contains new features and or major performance improvements and shall be marked as a new version number. For example, should Licensee purchase The Software under version 1.X.X, an upgrade shall commence under number 2.0.0.
% 5.2.	Updates: for the purpose of this license, an update shall be a minor amendment in The Software, which may contain new features or minor improvements and shall be marked as a new sub-version number. For example, should Licensee purchase The Software under version 1.1.X, an upgrade shall commence under number 1.2.0.
% 5.3.	Fix: for the purpose of this license, a fix shall be a minor amendment in The Software, intended to remove bugs or alter minor features which impair the The Software's functionality. A fix shall be marked as a new sub-sub-version number. For example, should Licensee purchase Software under version 1.1.1, an upgrade shall commence under number 1.1.2.
% 6.	Support: Software is provided under an AS-IS basis and without any support, updates or maintenance. Nothing in this Agreement shall require Licensor to provide Licensee with support or fixes to any bug, failure, mis-performance or other defect in The Software.
% 6.1.	Bug Notification: Licensee may provide Licensor of details regarding any bug, defect or failure in The Software promptly and with no delay from such event; Licensee shall comply with Licensor's request for information regarding bugs, defects or failures and furnish him with information, screenshots and try to reproduce such bugs, defects or failures.
% 6.2.	Feature Request: Licensee may request additional features in Software, provided, however, that (i) Licensee shall waive any claim or right in such feature should feature be developed by Licensor; (ii) Licensee shall be prohibited from developing the feature, or disclose such feature request, or feature, to any 3rd party directly competing with Licensor or any 3rd party which may be, following the development of such feature, in direct competition with Licensor; (iii) Licensee warrants that feature does not infringe any 3rd party patent, trademark, trade-secret or any other intellectual property right; and (iv) Licensee developed, envisioned or created the feature solely by himself.
% 7.	Liability:  To the extent permitted under Law, The Software is provided under an AS-IS basis. Licensor shall never, and without any limit, be liable for any damage, cost, expense or any other payment incurred by Licensee as a result of Software’s actions, failure, bugs and/or any other interaction between The Software  and Licensee’s end-equipment, computers, other software or any 3rd party, end-equipment, computer or services.  Moreover, Licensor shall never be liable for any defect in source code written by Licensee when relying on The Software or using The Software’s source code.
% 8.	Warranty:  
% 8.1.	Intellectual Property: Licensor hereby warrants that The Software does not violate or infringe any 3rd party claims in regards to intellectual property, patents and/or trademarks and that to the best of its knowledge no legal action has been taken against it for any infringement or violation of any 3rd party intellectual property rights.
% 8.2.	No-Warranty: The Software is provided without any warranty; Licensor hereby disclaims any warranty that The Software shall be error free, without defects or code which may cause damage to Licensee’s computers or to Licensee, and that Software shall be functional. Licensee shall be solely liable to any damage, defect or loss incurred as a result of operating software and undertake the risks contained in running The Software on License’s Server[s] and Computers[s].
% 8.3.	Prior Inspection: Licensee hereby states that he inspected The Software thoroughly and found it satisfactory and adequate to his needs, that it does not interfere with his regular operation and that it does meet the standards and scope of his computer systems and architecture. Licensee found that The Software interacts with his development, website and server environment and that it does not infringe any of End User License Agreement of any software Licensee may use in performing his services. Licensee hereby waives any claims regarding The Software's incompatibility, performance, results and features, and warrants that he inspected the The Software.
% 9.	No Refunds: Licensee warrants that he inspected The Software according to clause 7(c) and that it is adequate to his needs. Accordingly, as The Software is intangible goods, Licensee shall not be, ever, entitled to any refund, rebate, compensation or restitution for any reason whatsoever, even if The Software contains material flaws.
% 10.	Indemnification: Licensee hereby warrants to hold Licensor harmless and indemnify Licensor for any lawsuit brought against it in regards to Licensee’s use of The Software in means that violate, breach or otherwise circumvent this license, Licensor's intellectual property rights or Licensor's title in The Software. Licensor shall promptly notify Licensee in case of such legal action and request Licensee’s consent prior to any settlement in relation to such lawsuit or claim.
% 11.	Governing Law, Jurisdiction: Licensee hereby agrees not to initiate class-action lawsuits against Licensor in relation to this license and to compensate Licensor for any legal fees, cost or attorney fees should any claim brought by Licensee against Licensor be denied, in part or in full.


%subclass of "hgsetget" to gain access to pointer like behavior of "handle"
%superclass and set/get features of "hgsetget"
classdef HoloStack < hgsetget  
properties (SetAccess = protected) %write access limited
   % Setting protected properties only seems to cause me lots of headaches
end
properties
    %array/image data
    holos %array of HoloClass objects
    % refs %array of HoloClass objects
    
    hp % HoloReconP object that has all the reconstruction parameters in it.
    holoSum % Holoclass object, contains all the getSum() products.
   
    %variable data
    holofiles %strings
    % reffiles % strings of reference filenames
    numFrames = 0; %integer: number of holos in stack, number of references must be the same
    ordering %integer: indexed order of holos, first holo is used as base

    % Heurestic parameters
    name = '' %string: name assigned to a HoloStack
    baseIdx = 1; %integer: %location of base holo, caclulated based on value of baseChoice (needs to be set if 'Custom' is used)
    defaultAlignMethod = 'MWAlign'; %defines which alignment method is used, other option is 'Average' and 'PDiffAlign'
    defaultAlignField = 'center';
    defaultTemplate = 'firstIndex'; % other is 'previous'
    
    % Reconstruction parameters
    xcWindow = [] % The window to x-correlate onto, [x1 y1 x2 y2]
    pmWindow = [] % The window to phase match with, defaults to xcWindow if not provided.
    xcorrReference = []; % Reference centerband amp/sideband phase for doing cross-correlation registrations.
    
    % Resized registered parameters
    minOffset = [0 0] % Minimum found offset in [x1 y1]
    maxOffset = [0 0] % Maximum found offset in [x1 y1]
    regSize = [0 0] %integers [x,y]
    profileWidth = 1; % for 1-D alignment
    
    % Phase matching parameters
    phaseShifts %double
    phiError % array, the difference in the phase shift of cumReg -- approximates phase resolution
    ampError % array, the difference in the amplitude of cumReg

    v_image; % image drift velocity, [v_i_x v_i_y] in (pix/s)
    D_image; % image drift diffusivity, [D_i_x D_i_y] in (pix^2/s)
    v_phase; % phase velocity, in (rad/s)
    D_phase; % phase diffusivity, in (rad^2/s)
end
methods

    %constructor function. Requires 0-3 parameters
    function this = HoloStack( holofilename, hp )
        %If at least 1 parameter, define HoloStack object's name
        if( nargin < 1 )
            error( 'HoloStack.HoloStack: Must pass in name for parsing' );
        else
            this.name = holofilename;
        end
        
        if( nargin < 2 )
            disp( 'Holostack.HoloStack: WARNING, no recon parameters passed in, using defaults' )
            this.hp = HoloReconP();
        else
            this.hp = hp;
        end
        
        % Start reading in the files in the directory in order until you
        % run out
        disp( 'TO DO: add support for DM3 and HDF5 stacks as well as individual files' );
        i = 1;
        sentinel = true;
        while( sentinel )
            filename1 = dir( [holofilename,num2str(i),'.dm3'] );
            if( isempty(filename1) )
                sentinel = false;
            else
                this.holofiles{i} = filename1.name;
                i = i + 1;
            end
        end
        
        if( isempty( this.holofiles ) )
            disp( 'HoloStack.HoloStack: No files found, ready for simulation data or you mistyped it' )
        else
            this.numFrames = length(this.holofiles);

            this.makeOrdering();

            newHolos(this.numFrames) = HoloClass(); %better way to initialize, ie array of objects??
            this.holos = newHolos;
            clear newHolos
            % Hologram code
            for j = this.ordering   
                curr = this.holos(j);

                %initialize holoclass values
                curr.number = j;
                curr.filename = this.holofiles{j};
                curr.hp = this.hp;
            end %for
        end
    end
    
    %make a copy of a HoloStack object.
    function new = copy(this,name)
        % Instantiate new object of the same class.
        new = feval(class(this));
        
        % Copy all non-hidden properties.
        p = properties(this);
        for i = 1:length(p)
            new.(p{i}) = this.(p{i});
        end
        % Copy all child objects
        for j = 1:this.numFrames
            new.holos(j) = this.holos(j).copy();
        end
        
        if(exist('name'))
            new.name = name;
        end
    
    end

    % remove a subset of holos from a HoloStack
    function removeHolo(this,removeIdx)
        %input removeIdx must contain unique values
        
        %remove holos
       this.holos(removeIdx).delete();
       keepIdx = setdiff(1:this.numFrames,removeIdx);
       this.holos = this.holos(keepIdx);

       %redo this.ordering
       removeIdx = sort(removeIdx,'descend'); %sort required
       for j=removeIdx
           if(ismember(j,this.ordering))
               fprintf('Removing: Holo %d\n',j);
               keepIdx = find(j~=this.ordering);
               this.ordering = this.ordering(keepIdx);
               jGreater = find(j<this.ordering);
               this.ordering(jGreater) = this.ordering(jGreater) - 1;
           else
               fprintf('Removing: Holo %d not found\n',j);
           end
       end
       this.baseIdx = this.ordering(1);
       this.numFrames = length(this.holos);
       
       % Redo phase shifts?
       % Redo cumulant
       this.findCumulants();
    end
    
    % Use this function to build a HoloStack using simulated data, of the
    % form sim_holo(x,y,m), where m is the hologram.  Similar to
    % readAndRecon in other respects.  Call the constructor with 1 or zero
    % arguments.
    function this = passSimHolo( this, holo_sim )
        this.numFrames = size( holo_sim, 3 );
        
        %choose which image to use as the base image based on the value of
        %baseChoice
        switch lower(this.hp.baseChoice)
            case 'first'
                this.baseIdx = 1;
            case 'middle'
                this.baseIdx = ceil(this.numFrames/2);
            case 'last'
                this.baseIdx = this.numFrames;
            case 'custom'
                if(~(this.baseIdx == 1:this.numFrames))
                    error('HoloStack: baseIdx value unset or out of range');
                end
            otherwise
                
                this.baseIdx = 1;
        end
        %define HoloStack ordering based on this.baseIdx
        this.ordering = [this.baseIdx:this.numFrames,this.baseIdx-1:-1:1];
        newHolos(this.numFrames) = HoloClass(); %better way to initialize, ie array of objects??
        this.holos = newHolos;
       
        %Read and reconstruct each holo
        for j = this.ordering   
            curr = this.holos(j);
            
            %initialize holoclass values
            curr.number = j;
            curr.hp = this.hp;
            
            % write a holo
            curr.holo = holo_sim(:,:,j);
            
            %reconstruct 
            fprintf('Recon holo: %d\n',j);
            curr.reconstruct();        
        end
    end
    
    % Pass in another holostack, that of the object, if this is to be used
    % as a reference set
    function setAsReference( this, hs_obj )
        this.minOffset = hs_obj.minOffset;
        this.maxOffset = hs_obj.maxOffset;
        this.regSize = hs_obj.regSize;
        this.register( 'Offset' );
    end

    %reads data in and reconstructs the sideband images
    function readAndRecon(this, fieldName )
        if( nargin < 2 );
            fieldName = 'holos';
        end
        
        if( strcmp( fieldName, 'holos' ) == 1 )
            this.makeOrdering();
            
            for j = this.ordering
                fprintf('Recon: %d\n',j);
                this.holos(j).reconstruct();
            end
        else
            disp( 'HoloStack.readAndRecon: Unkown fieldName passed in' )
        end
    end
    
    function makeOrdering( this )
                    %chose which image to use as the base image based on the value of
        %baseChoice
        switch lower(this.hp.baseChoice)
            case 'first'
                this.baseIdx = 1;
            case 'middle'
                this.baseIdx = ceil(this.numFrames./2.0);
            case 'last'
                this.baseIdx = this.numFrames;
            otherwise
                this.baseIdx = 1;
        end
        
        this.ordering = [this.baseIdx:this.numFrames,this.baseIdx-1:-1:1];


    end
    
    %registers the sideband images (shift and crop)
    function register(this, alignMethodName, alignMethodField, alignTemplate )
        % Register HoloStack to base holo.
        % First calculate offsets and then shift images (both offset and
        % phase) and crop all images to the same size. Finally apply a final
        % subpixel shift (both offset and phase)
        
        if( ~exist('alignMethodName') || isempty(alignMethodName) )
            alignMethodName = this.defaultAlignMethod;
        end
        if( ~exist('alignMethodField') || isempty(alignMethodField) )
            alignMethodField = this.defaultAlignField;
        end
        if( ~exist('alignTemplate') || isempty(alignTemplate) )
            alignTemplate = this.defaultTemplate;
        end

        if( strcmp(alignMethodName, 'Average') == 1 )
            % Sum and add all the reconstructed holograms
            % No need to compute offsets
            for j = this.ordering %uses predefined ordering
                curr = this.holos(j);
                curr.offset = [0 0];
            end
            % Do need to remove phase shifts
        elseif( strcmp(alignMethodName, 'Offset') == 1 )
            % This is for reference sets, it offsets the result by the same
            % amount as an associated as provided in this.regSize and this.maxOffset
            % In this way, we end up with equivalent sized data sets, but
            % there is some concern that there's no actual matching between
            % the reference and hologram!  
            
            % Perhaps some time we could actually x-correlate the entire
            % image of the reference to the hologram?
            
            for j = this.ordering %uses predefined ordering
                curr = this.holos(j);
                curr.offset = [0 0];
                % curr.regcenterband = curr.centerband;
            end
            
            disp( 'RM: for offset mode the regSize should be set prior to calling HoloStack.register()' );
            % RM: for 'offset' mode the maxOffset and minOffset should be set
            % prior to calling HoloStack.register();
            disp( 'RM: Offset alignment mode zeros out the offset, use baseChoice as Middle' );
        elseif( strcmp( alignMethodName, 'OneDim' ) == 1 )
            % This is a one dimensional alignment routine, which is more
            % ideal for FIB prepared cross-sections where we cannot observe
            % 2-D motion, and in general don't care anyway.
            % POTENTIAL FUTURE EXTENSION: do 1-D for first pass and then
            % 2-D after
            % Requires profile_int.m
            

            
             % Should be no need to treat baseIdx seperately
             for j = this.ordering
                % In this case, the xcWindow is the end-points of the
                % cross-correlation.
                if( strcmp(alignTemplate, 'firstIndex') == 1 )
                    base = this.holos(this.ordering(1));
                elseif( strcmp(alginTemplate, 'previousIndex') == 1 )
                    if( j == 1 )
                        base = this.holos(this.ordering(1));
                    else
                        base = this.holos(this.ordering(j-1));
                    end
                else
                    error( 'HoloStack.register: unknown alignTemplate passed in' );
                end
                
                curr = this.holos(j);

                curr.calcOffset1D(base,alignMethodName, alignMethodField, 1 );

                disp( [ 'CalcOffset 1-D (', num2str(j), '): ' ,  num2str( curr.offset(1) ,'%.2f'), ', ', num2str( curr.offset(2),'%.2f'), ' pix' ] )
             end
            
        else  % Vismap or MWAlign or PDDiffAlign
            % Calculate offsets
            for j = this.ordering %uses predefined ordering
                if(j==this.baseIdx-1) %reset prevOffset when ordering jumps back to base location
                    prevOffset = firstOffset;
                end
                curr = this.holos(j);

                
                xcorrRef = this.xcorrReference; % Can't do exist() checks on properties for some reason.
                
                if(j==this.baseIdx) %treat first/base holo differently
                    
                    % RM: Autocorrelate the base to itself, only really
                    % required for the x-correlation movie.
                    if( ~isempty( xcorrRef ) )

                        if( strcmp( this.hp.xcMethod, 'general') == 1 )
                            curr.calcOffset_general(curr,alignMethodName, alignMethodField, this.xcorrReference );
                        else % masked
                            curr.calcOffset_masked(curr,alignMethodName, alignMethodField, this.xcorrReference );
                        end
                    else 
                        if( strcmp( this.hp.xcMethod, 'general') == 1 )
                            curr.calcOffset_general(curr,alignMethodName, alignMethodField );
                        else % masked
                            curr.calcOffset_masked(curr,alignMethodName, alignMethodField );
                        end
                    end
                    curr.offset = [0 0];
                    base = curr;
                    firstOffset = curr.offset; %store first offset to reset prevOffset when ordering jumps
                else
                    if( strcmp(alignTemplate, 'firstIndex') == 1 )
                        base = this.holos(this.ordering(1));
                    elseif( strcmp(alignTemplate, 'previousIndex') == 1 )
                        if( j == 1 )
                            base = this.holos(this.ordering(1));
                        else
                            base = this.holos(this.ordering(j-1));
                        end
                    else
                        error( 'HoloStack.register: unknown alignTemplate passed in' );
                    end
                    
                    if( ~isempty( xcorrRef ) )
                        % First xc is just an autocorrelation
                        
                        if( strcmp( this.hp.xcMethod, 'general') == 1 )
                            curr.calcOffset_general(base,alignMethodName, alignMethodField, this.xcorrReference );
                        else % masked
                            curr.calcOffset_masked(base,alignMethodName, alignMethodField, this.xcorrReference );
                        end
                    else 
                        if( strcmp( this.hp.xcMethod, 'general') == 1 )
                            curr.calcOffset_general(base,alignMethodName, alignMethodField );
                        else % masked
                            curr.calcOffset_masked(base,alignMethodName, alignMethodField );
                        end
                    end
                    
                end
                disp( [ 'CalcOffset_', this.hp.xcMethod, ' (', num2str(j), '): ' ,  num2str( curr.offset(1) ,'%.2f'), ', ', num2str( curr.offset(2),'%.2f'), ' pix' ] )
                % prevOffset = curr.offset; % DEBUG: prevOffset has been disabled above.
            end

        end
        
        % If we used 'previousIndex' for the template then we need to find
        % the cumsum of the offset series;
        if( strcmp(alignTemplate, 'previousIndex') == 1 )
            offsets = this.getOffsets();
            csum_offsets = zeros( size(offsets) );
            
            for j = 1:this.numFrames     
                csum_offsets(j,:) = sum( offsets(this.ordering(1:j),:), 1);
                this.holos(j).offset = csum_offsets(j,:);
            end
                    
        end
        
        % calculate size of cropped images based maximum x,y offsets
        if( strcmp(alignMethodName, 'Offset') ~= 1 && strcmp(alignMethodName, 'Average') ~= 1 )
            % Perform for most methods, but not Offset
            offsets = this.getOffsets();
            this.minOffset = min(offsets,[],1);
            this.maxOffset = max(offsets,[],1);
        end

        if( strcmp(alignMethodName, 'Average') ~= 1 )
            % RM: for 'offset' mode the maxOffset and minOffset should be set
            % prior to calling HoloStack.register();
            disp( 'HoloStack.register: Performing image cropping' );
            cropSpace = ceil(abs(this.maxOffset - this.minOffset));
            cropSpace = cropSpace - mod(cropSpace,2); %make sure new size is even
            this.regSize = this.hp.reconSize - cropSpace;
            
            this.correctImage();
        end
        
        this.correctPhase( alignMethodName );
        
        if( this.hp.doCums )
            % keep a cummulative averaged image set
            this.findCumulants();
        end
        
        % Build the holoSum object
        this.buildHoloSum();
        
        if( this.hp.keepUnreg == false )
            % Delete the sideband, centerband, and holovismap if they
            % exist.
            disp( 'DELETING: All unregistered data' );
            for j = this.ordering
                this.holos(j).side = [];
                this.holos(j).center = [];
                this.holos(j).vismap = [];
            end
        end

    end
    
    function correctImage( this )
        %apply offsets and crop images, 
        for j = this.ordering %uses predefined ordering
            % Function can either run based on the first frame in the series,
            % which is noisy, or you can pass it in a base image (typically the
            % sumHolo object) for subsequent iterations of the registration.
            curr = this.holos(j);
            curr.shift(this.maxOffset,this.regSize);
        end
    end
    
    function correctPhase( this, alignMethodName, base )
        % Function can either run based on the first frame in the series,
        % which is noisy, or you can pass it in a base image (typically the
        % sumHolo object) for subsequent iterations of the registration.
        
        if( ~exist( 'alignMethodName' ) || isempty( alignMethodName ) )
            alignMethodName = this.defaultAlignMethod;
        end
        
        if( ~exist( 'base' ) || isempty( base ) )
            % Set base as the first frame in the ordering
            base = this.holos(this.ordering(1));
        else
            disp( 'HoloStack.correctPhase using provided base for calculating phase shifts' );
        end
        
        
        
        for j = this.ordering %uses predefined ordering
            % PHASE CORRECTION AFTER REGISTRATION AND AFTER SHIFTING
            curr = this.holos(j);
            if( strcmp(alignMethodName, 'Average') == 1 || strcmp(alignMethodName, 'Offset') )
                % disp( 'HoloStack.correctPhase: Phase shifting UN-REGISTERED sideband');
                [pShift] = curr.shiftPhase(base,'side');
                
            elseif( strcmp(alignMethodName, 'MWAlign') == 1  )
                % disp( 'HoloStack.correctPhase: Phase shifting REGISTERED sideband');
                [pShift] = curr.shiftPhase(base,'regside');
                
            elseif( strcmp( alignMethodName, 'OneDim' ) == 1 )
                % disp( 'HoloStack.correctPhase: Phase shifting 1-D on registered sideband');
                [pShift] = curr.shiftPhase(base, 'regside' );
                
            else
                disp( ['HoloStack.correctPhase: unknown alignment method: ', alignMethodName ] )
            end
            disp( [ 'Phase shift (', num2str(j), '): ', num2str( pShift ), ' rad' ] )
        end
    end
    
    function findCumulants( this )
        % Calculate cumulative sideband and registered sideband
        for j = 1:this.numFrames %uses predefined ordering    
            
            disp( ['Computing hologram cumulant #', num2str(j) ] );
            if( j == 1 ) % First in the series.
                this.holos(this.ordering(j)).cumSide= this.holos(this.ordering(j)).side;
                this.holos(this.ordering(j)).cumReg = this.holos(this.ordering(j)).regside;
            else % jindex > frame #1 in the series, whereever it is...
                this.holos(this.ordering(j)).cumSide = this.holos(this.ordering(j)).side + this.holos(this.ordering(j-1)).cumSide;
                this.holos(this.ordering(j)).cumReg = this.holos(this.ordering(j)).regside + this.holos(this.ordering(j-1)).cumReg;
            end
        end 
    end
    
    function buildHoloSum( this )
        % Create a new HoloClas
        this.holoSum = this.holos(this.ordering(1)).copy();
        
        % Copy over summed fields
        this.holoSum.side = this.getSum( 'holos', 'side' );
        this.holoSum.center = this.getSum( 'holos', 'center' );
        this.holoSum.vismap = this.getSum( 'holos', 'vismap' );
        this.holoSum.regside = this.getSum( 'holos', 'regside' );
        this.holoSum.regcenter = this.getSum( 'holos', 'regcenter' );
        this.holoSum.regvismap = this.getSum( 'holos', 'regvismap' );
        
        % Find total dose, in counts per pixel
        this.holoSum.dose = 0;
        this.holoSum.visibility = 0;
        for j = this.ordering
            this.holoSum.dose = this.holoSum.dose + this.holos(j).dose;
            this.holoSum.visibility = this.holoSum.visibility + this.holos(j).visibility;
        end
        this.holoSum.visibility = this.holoSum.visibility ./ this.numFrames;
        
        
    end
    
    % Draw a rectangle to limit xcorrelation to.
    function drawxcMaskRect( this )
        % Grab centerband
        workcenter = this.holos(this.ordering(1)).center;
        
        if( isempty( workcenter ) )
            % Ask this.holos(this.ordering(1)) to reconstruct itself
            this.holos( this.ordering(1) ).reconstruct();
            workcenter = this.holos(this.ordering(1)).center;
        end
        
        fig = figure( 'units', 'normalized', 'outerposition', [0 0 1 1] );
        imagesc( workcenter, histClim( workcenter,3) );
        axis image;
        title( ['Rectangle to define xcorrelation region \newline Click and drag \newline Double click on rect to finish'] );
        h = imrect();
        position = wait(h); % This is just to make MATLAB wait on the poly to return
        
        % Position is [xmin ymin width height]
        this.hp.xcWindow = round( [position(1), position(2), position(1)+position(3), position(2)+position(4)] );
        
        close( fig );
        pause(0.05);
    end
    
    % Draw a rectangle to limit phase matching to.  At present this cannot
    % be done free-hand because of the methodology used to calculate the
    % phase-match error without phase-wrapping problems.
    function drawpmMaskRect( this )
        % Grab sideband
        workside = angle( this.holos(this.ordering(1)).side );
        
        if( isempty( workside ) )
            % Ask this.holos(this.ordering(1)) to reconstruct itself
            this.holos( this.ordering(1) ).reconstruct();
            workside = angle( this.holos(this.ordering(1)).side );
        end
        
        fig = figure( 'units', 'normalized', 'outerposition', [0 0 1 1] );
        imagesc( workside, histClim( workside,3) );
        axis image;
        title( ['Rectangle to define phase-matching region \newline Click and drag \newline Double click on rect to finish'] );
        h = imrect();
        position = wait(h); % This is just to make MATLAB wait on the poly to return

        % Position is [xmin ymin width height]
        this.hp.pmWindow = round( [position(1), position(2), position(1)+position(3), position(2)+position(4)] );
        
        close( fig );
        pause(0.05);
    end
    
    
    % Draw a mask over the centerband reconstruction to define the
    % x-correlation region.  Will reconstruct the centerband of the first
    % hologram in the ordering if it hasn't already been done.
    function drawxcMaskFreehand( this )
        % Grab centerband
        workcenter = this.holos(this.ordering(1)).center;
        
        if( isempty( workcenter ) )
            % Ask this.holos(this.ordering(1)) to reconstruct itself
            this.holos( this.ordering(1) ).reconstruct();
            workcenter = this.holos(this.ordering(1)).center;
        end
        
        fig = figure( 'units', 'normalized', 'outerposition', [0 0 1 1] );
        imagesc( workcenter, histClim( workcenter,3) );
        axis image;
        title( ['Vertices to define xcorrelation region \newline Right-click to stop \newline Double click on poly to finish'] );
        h = impoly();
        position = wait(h); % This is just to make MATLAB wait on the poly to return
        
        this.hp.xcMask = h.createMask();
        close( fig );
        pause(0.05);
%         figure;
%         imagesc( h.createMask() );
%         axis image;
%         title( 'Mask' );
    end
    
    %calcluate the average of the data contained in a HoloClass field
    %(fieldName) using (dataSize) images
    % e.g. HSholo.getSum('holo','sideband')
    function out = getSum(this,fieldType,fieldName,dataSize)

        if( ~exist('dataSize') || isempty(dataSize) )
            dataSize = this.numFrames;
        end
        
        if(dataSize == 1)
            out = this.(fieldType)(this.baseIdx).(fieldName);
        else
            dSet = this.getDataSet(fieldType,fieldName,dataSize);
            out = squeeze(sum(dSet,1)); % sum
        end
        
        % For visibility map and registered visibility map, we still need
        % to take the mean
        switch( fieldName )
            case 'vismap'
                out = out ./ dataSize;
            case 'regvismap'
                out = out ./ dataSize;
        end
        
    end
    
    %Create a data array (dataSet) from a HoloClass field (fieldName)
    %and limit the size of the array (dataSize)
    function dataSet = getDataSet(this,fieldType,fieldName,dataSize)
        if(~exist('dataSize', 'var')) 
            dataSize = this.numFrames; 
        end

        iDims = size(this.(fieldType)(this.baseIdx).(fieldName));
        
        %Get 1:dataSize images based on the ordering of the holograms
        %defined in this.ordering
        dataSetRange = this.ordering(1:dataSize);
        dataSet = [this.(fieldType)(dataSetRange).(fieldName)];

        dataSet = reshape(dataSet,iDims(1),iDims(2),dataSize);
        dataSet = shiftdim(dataSet,2);
    end

    % create a movie of a image set based on fieldName
    % if fileHeader is defined, then output movie to an avi file
    % otherwise display on screen. MAXIMUM SIZE OF MOVIE FRAMES IS [512 512] 
    function [aMov,pMov] = makeMovie(this,fieldName,fileHeader, frameRate)

        if( nargin < 4 )
            frameRate = 2;
        end
        
        setSize = length(this.holos);
        
        % if the fieldName is holo we may need to reload them all from
        % memory
        if( strcmp( fieldName, 'holo' ) )
            if( isempty( 'this.holos(1).holo' ) )
                for j = 1:length( this.holos )
                    dm3struct = DM3Import( this.holofiles(j));
                    this.holos(j).holo = dm3struct.image_data;
                end
            end
            movieSize = [512 512];
        elseif( strcmp( fieldName, 'ref' ) )
            warning( 'DEBUG: no ability to make reference movies at present' )
        else % not fieldname == holo
            movieSize = size( this.holos(1).(fieldName) )
        end
        
        % Notice that this can cause scaling issues if the image happens to
        % be rectangular
        if( movieSize(1) > 512 || movieSize(2) > 512 )
            movieSize = [512 512];
            resize_flag = 1;
        else
            resize_flag = 0;
        end
        % Special handling for xc movies
        if( strcmp( fieldName, 'xc') == 1 )
            movieSize = [512 512];
            resize_flag = 1;
        end
        
        phase_flag = ~isreal( this.holos(1).(fieldName) );
        
        
        figure; movegui;
        
        for j=1:setSize
            currObj = this.holos(j).(fieldName);
            

            if( j == 1 )
%                     % if there's a refvis then use that for contrast limits
%                     refvis = this.getSum( 'refs', 'regvismap' );
%                     if( ~isempty( refvis )  )
%                         disp( 'Using reference vismap (via holoClim) for contrast limits' )
%                         [Imin, Imax] = holoClim( refvis, currObj, 2.0 );
%                     else
                    % Force contrast limits based on cimedfilt2 results on first frame
                    % (for non-phase images only)
                    disp( 'Using histClim to determine contrast limits' )
                     clim = histClim( abs(currObj), 3.0 );
                     Imax = clim(2);
                     Imin = clim(1);
%                     end
%                     Imin
%                     Imax
            else
                % Do nothing
            end

            
            if( resize_flag )
                amplitude = imresize( abs(currObj), movieSize );
                if( phase_flag ) phase = imresize( angle(currObj), movieSize ); end
            else % no need to do a useless resize
                amplitude = abs(currObj);
                if( phase_flag ) phase = angle(currObj); end
            end
            % Find reasonable limits for the colormap and fix them so they
            % are the same frame to frame.
            
            imagesc( amplitude, [Imin, Imax] );
            axis image;
            title( [fieldName,': A: ',num2str(j)] );
            colormap(jet(256));
            colorbar( 'Location', 'South' )
            aMov(j) = getframe;
                        
            if( phase_flag ) 
                % imagesc(phase);
                imagesc( phase, [-pi, pi] );
                axis image;
                title( [fieldName,': P: ',num2str(j)] );
                colormap( jet(256) );
                colorbar( 'Location', 'South' )
                pMov(j) = getframe;
            end
            
        end
        
        if(exist('fileHeader'))
            movie2avi( aMov, [fileHeader,'Amp'], 'fps',frameRate, 'compression', 'none' );
            
            if( phase_flag ) movie2avi( pMov, [fileHeader,'Phase'], 'fps',frameRate, 'compression', 'none' ); end
        else
            figure; movegui;
            movie(aMov,10,frameRate);
            if( phase_flag ) 
                figure; movegui;
                movie(pMov,10,frameRate);
            end
        end
    end
    
    %display a HoloStack in various ways
    % depricated at present, could use an update
    function outFigure = display(this,fieldName,displayType,label,inFigure)

        %print general info about HoloStack if no parameters are supplied
        if(nargin == 1)
            disp(this)
%             fprintf('HoloStack Object Summary:\n');
%             fprintf('  HoloStack Name: %s\n',this.name);
%             fprintf('  Number of Holos: %d\n',this.numFrames);
%             fprintf('  Base Holo Index: %d\n',this.baseIdx);
%             fprintf('  Size of Reconstructed Holos: %d x %d \n',this.reconSize);
%             fprintf('  Size of Registered Holos: %d x %d \n',this.regSize);
%             if(length(this.xcWindow)==4)
%                 fprintf('  Cross-Correlation window min (%d,%d) max (%d,%d)\n',this.xcWindow);
%             end
%             fprintf('  Search Size (%d, %d)\n',this.searchSize);
%             fprintf('  Holo Ordering: ');
%             fprintf('%d ',this.ordering);
%             fprintf('\n\n');
%             %fprintf('Matlab Object Details:\n');
%             %display@hgsetget(this);
             return;
        end
            
        if(~exist('label')) label = ''; end
        if(~exist('inFigure')) 
            inFigure = figure;
            newFigure = true;
        else
            newFigure = false;
            hold on;
        end
        if(isempty(inFigure)) 
            inFigure = figure;
            hold off;
        end
        
        setSize = length(this.holos);
        
        switch lower(displayType)
            case 'all'
                this.display(fieldName,'AllAmp',label,inFigure);
                this.display(fieldName,'AllPhase',label);
                outFigure = [];
            case 'allamp'
                colsize = ceil(sqrt(setSize));
                rowsize = ceil(setSize./colsize);
                figure(inFigure); movegui;
                for j=1:setSize
                    
                    currImage = this.holos(j).(fieldName);
                    amplitude = abs(currImage);
                    
                    subplot(rowsize,colsize,j);
                    imagesc(amplitude);
                    title( [label,': ',fieldName,': A: ',num2str(j)] );
                    axis image;
                    colormap('gray');
                    
                end
                outFigure = [];
            case 'allphase'
                setSize = length(this.holos);
                colsize = ceil(sqrt(setSize));
                rowsize = ceil(setSize./colsize);
                figure(inFigure); movegui;
                for j=1:setSize
                    
                    currImage = this.holos(j).(fieldName);
                    phase = angle(currImage);
                    
                    subplot(rowsize,colsize,j);
                    imagesc(phase);
                    title( [label,': ',fieldName,': P: ',num2str(j)] );
                    axis image;
                    colormap('jet');
                    
                end
                outFigure = [];
            case 'avg'
                avgData = this.getSum(fieldName);
                ampImage = abs(avgData);
                phaseImage = angle(avgData);
                
                figure(inFigure); movegui;
                subplot(1,2,1);
                imagesc(ampImage);
                title( [label,': Amp'] );
                axis image;
                shading interp;
                %colorbar;
                colormap('jet');
                
                subplot(1,2,2);
                imagesc(phaseImage);
                axis image;
                title( [label,': Phase'] );
                outFigure = [];
            case 'avgamp'
                avgData = this.getSum(fieldName);
                ampImage = abs(avgData);
                
                figure(inFigure); movegui;
                imagesc(ampImage);
                title( [label,': Amp'] );
                axis image;
                shading interp;
                %colorbar;
                colormap('jet');
                outFigure = [];
            case 'avgphase'
                avgData = this.getSum(fieldName);
                phaseImage = angle(avgData);
                
                figure(inFigure); movegui;
                imagesc(phaseImage);
                title( [label,': Phase'] );
                axis image;
                shading interp;
                %colorbar;
                colormap('jet');
                outFigure = [];
            case 'searcharea'
                phaseImage = angle(this.holos(this.baseIdx).(fieldName));
                figure; movegui;
                imagesc(phaseImage); 
                title( [label,': Phase'] );
                hold on
                if(~isempty(this.xcWindow))
                    xCoord = this.xcWindow([1,3,3,1,1]);
                    yCoord = this.xcWindow([2,2,4,4,2]);
                    line(xCoord,yCoord,'Color','b');
                    searchWindow = this.xcWindow + [-this.searchSize./2,this.searchSize./2];
                    xCoord = searchWindow([1,3,3,1,1]);
                    yCoord = searchWindow([2,2,4,4,2]);
                    line(xCoord,yCoord,'Color','y');
                end
                hold off;
                %this.holos(this.baseIdx).display(fieldName,'SearchArea');
                
            case 'error'
                errorData = this.getError(this.getSum(fieldName),fieldName);
                figure(inFigure); movegui;
                plot(errorData);
                xlabel('hologram index');
                ylabel('NRMSE');
                title([label,': ',fieldName, ' : Normalized RMS Error with respect to mean data']);
                outFigure = inFigure; 

                if(newFigure)                             
                    fprintf('\nRMS Error compared to mean data for FieldName: %s\n',fieldName);
                    printRows(1:length(errorData),'holoidx');
                end
                printRows(errorData,this.name);
            case 'offsets'
                
                figure(inFigure); movegui;
                offsetData = reshape([this.holos.offset],2,setSize);
                line(offsetData(1,:),offsetData(2,:),'Color','r','Marker','o');
                xlabel('x shift');
                ylabel('y shift');
                title([label,': ',fieldName, ' : offset plots']);
                outFigure = inFigure; 

                if(newFigure)                             
                    fprintf('\nOffset data \n');
                    printRows(1:length(offsetData),'holoidx');
                end
                printRows(offsetData,[this.name,':x';this.name,':y']);

            case 'stats'
                
                
            otherwise
                error('HoloStack:display displayType is undefined');
        end
        
        hold off;
    end
    
    % Try to plot the sums of all the present fields
    % Can be passed a reference HoloStack
    function [] = plotAll( this, sigma, refholostack, useFringeMask )
        
        % ps = pixel size in nm
        if nargin < 2
            sigma = 2.5; % Don't produce any scale bars
        end
        if ~exist( 'useFringeMask' ) || isempty( useFringeMask )
            useFringeMask = true;
        end
        if ~exist( 'refholostack' ) || isempty( refholostack )
            % Do nothing
        else
            regref = refholostack.holoSum.regside;
            refcenter = refholostack.holoSum.regcenter;
            if( useFringeMask )
                reffringemask = fringemask( refholostack.holoSum.regvismap );
            end
        end
        
        if ~exist( 'refholostack' ) || isempty( refholostack )
            regholo = this.holoSum.regside;
            unphase = FouUnwrap( angle(this.holoSum.regside) );
            regcenter = this.holoSum.regcenter;
            vis = this.holoSum.regvismap;
        else
            vis = this.holoSum.regvismap;
            regholo = this.holoSum.regside ./ regref;
            
            if( useFringeMask )
                regcenter = this.holoSum.regcenter ./refcenter .* reffringemask;
                unphase = FouUnwrap( angle(regholo) ) .* reffringemask;
                regholo = regholo  .* reffringemask;
            else
                regcenter = this.holoSum.regcenter ./refcenter;
                unphase = FouUnwrap( angle(regholo) );
                % regholo = regholo;
            end
        end
        

        fig = figure; movegui;
        h = axes();
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        imagesc( vis, histClim( vis, sigma ) );
        axis image;
        title( ['Visibility map (individual): ', this.name] )
        axis off;
        colormap( jet(256))
        colorbar( 'Location', 'North', 'FontName', 'Times', 'FontWeight', 'Demi', 'FontSize', 12 )
        if( this.hp.ps_recon ~= 0.0 )
            scalebar( h,'color',[0 0 0],'Units','nm','PixelScale',this.hp.ps_recon);
        end

%         fig = figure; movegui;
%         h = axes();
%         set(gca, 'FontSize', 12.0 );
%         set(gca, 'FontWeight', 'Demi' );
%         imagesc( 2.*abs(regholo)./regcenterholo, histClim( 2.*abs(regholo)./regcenterholo, sigma ) );
%         axis image;
%         title( ['Visibility map (summed bands): ', this.name] )
%         axis off;
%         colormap( jet(256))
%         colorbar( 'Location', 'North' )
%         if( ps ~= 0.0 )
%             scalebar( h,'color',[0 0 0],'Units','nm','PixelScale',ps);
%         end

        fig = figure; movegui;
        h = axes();
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        imagesc( cimedfilt2(regcenter), histClim( regcenter, sigma ) );
        axis image;
        title( ['Registered centerband amplitude: ', this.name] )
        axis off
        colormap( jet(256))
        colorbar( 'Location', 'North', 'FontName', 'Times', 'FontWeight', 'Demi', 'FontSize', 12 )
        if( this.hp.ps_recon ~= 0.0 )
            scalebar( h,'color',[1 0 0],'Units','nm','PixelScale',this.hp.ps_recon);
        end
        
        fig = figure; movegui;
        h = axes();
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        imagesc( cimedfilt2( abs(regholo)), histClim( cimedfilt2( abs(regholo)), sigma )  );
        axis image;
        title( ['Registered sideband amplitude: ', this.name] )
        axis off
        colormap( jet(256))
        colorbar( 'Location', 'North', 'FontName', 'Times', 'FontWeight', 'Demi', 'FontSize', 12 )
        if( this.hp.ps_recon ~= 0.0 )
            scalebar( h,'color',[1 0 0],'Units','nm','PixelScale',this.hp.ps_recon);
        end

        disp( 'No fringe mask for the phase image' )
        [Clim_unphase] = histClim( unphase, sigma );
        fig = figure; movegui;
        h = axes();
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        imagesc( unphase, Clim_unphase );
        axis image;
        title( ['Registered unwrapped phase: ', this.name] )
        axis off;
        colormap( jet(256))
        colorbar( 'Location', 'North', 'FontName', 'Times', 'FontWeight', 'Demi', 'FontSize', 12 )
        if( this.hp.ps_recon ~= 0.0 )
            scalebar( h,'color',[1 1 1],'Units','nm','PixelScale',this.hp.ps_recon);
        end

        offsets = this.getOffsets();
        offsets = offsets .* (this.hp.holoSize(1) ./ this.hp.reconSize(1) );
        if( ~isempty( this.hp.ps_recon ) )
            offsets = offsets.*this.hp.ps_recon;
        end

        fig = figure; movegui;
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        plot( offsets(:,1), offsets(:,2), 'ro-', 'LineWidth', 2, 'MarkerSize', 10 );
        title( ['Estimated drift: ', this.name] )
        legend( 'Estimated Drift' )
        if( ~isempty( this.hp.ps_recon ) )
        	xlabel( 'x_{drift} (nm)', 'FontSize', 16.0, 'FontWeight', 'Demi' );
            ylabel( 'y_{drift} (nm)', 'FontSize', 16.0, 'FontWeight', 'Demi' );
        else
            xlabel( 'x_{drift} (pix)', 'FontSize', 16.0, 'FontWeight', 'Demi' );
            ylabel( 'y_{drift} (pix)', 'FontSize', 16.0, 'FontWeight', 'Demi' );
        end


        pshifts = this.getPhaseShifts();
        fig = figure; movegui;
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        plot( pshifts, 'bo-', 'LineWidth', 2, 'MarkerSize', 10 );
        title( ['Estimated phase drift: ', this.name] )
        xlabel( 'Frame number, m', 'FontSize', 16.0, 'FontWeight', 'Demi'  );
        ylabel( 'Estimated Phase Drift, \phi (rad)', 'FontSize', 16.0, 'FontWeight', 'Demi' );
        
    end
    
    % Return the pixel shifts used for alignment
    function [offsets] = getOffsets( this )
        offsets = zeros( [ this.numFrames, 2] );

        for j = 1:this.numFrames
            offsets(j,:) = this.holos(j).offset;
        end
        
        if( ~isempty( this.hp.dt ) && this.hp.dt ~= 0 )
            % Find mean drift velocity and from the std the diffusivity
            this.v_image = mean( diff(offsets), 1 ) ./ this.hp.dt;
            this.D_image = var( diff(offsets), [], 1 ) ./ (4.*this.hp.dt);
        end
        disp( [ 'Mean image velocity, v_i = ', num2str(this.v_image), ' pix/s and D_i = ', num2str( this.D_image ) ' pix^2/s' ] )
    end
    
    % Return the phase shifts used for phase matching
    function [pshifts] = getPhaseShifts( this, fieldName )
        if( nargin < 2 )
            fieldName = 'holos';
        end
        
        pshifts = zeros( [ this.numFrames, 1] );
        for J = 1:this.numFrames
            pshifts(J) = this.(fieldName)(J).pShift;
        end
        
        if( ~isempty( this.hp.dt ) && this.hp.dt ~= 0 )
            % Find mean drift velocity and from the std the diffusivity
            this.v_phase = mean( diff(pshifts) ) ./ this.hp.dt;
            this.D_phase = var( diff(pshifts) ) ./ (2.*this.hp.dt);
        end
        disp( [ 'Mean phase velocity, v_phi = ', num2str(this.v_phase), ' rad/s and D_phi = ', num2str( this.D_phase ) ' rad^2/s' ] )
    end
    
    % Return error map estimates (radians for phase) -- VERY ROUGH NOT
    % SUITABLE FOR PUBLICATION
    function [pErr, aErr] = calcError( this, fieldName, holoField )
        if( nargin < 2 )
            fieldName = 'holos';
        end
        if( nargin < 3 )
            holoField = 'cumReg';
        end
        % Use HoloClass function [pStd] = calcPhaseErr( this, base, fieldName )
        pErr = zeros( [this.numFrames - 1 1] );
        aErr = zeros( [this.numFrames - 1 1] );
        for J = 2:this.numFrames
            [pErr(J-1), aErr(J-1)] = this.(fieldName)(J).calcPhaseErr( this.(fieldName)(J-1), holoField );
        end
        
        this.phiError = pErr;
        this.ampError = aErr;
    end
    
    % It would be nice if I wrapped up these three functions into one.
    function [meanVis] = getVisibility( this )
        meanVis = zeros( [ this.numFrames, 1] );
        for J = 1:this.numFrames
            meanVis(J) = this.holos(J).visibility;
        end
    end
    
    function [meanDose] = getDose( this )
        meanDose = zeros( [ this.numFrames, 1] );
        for J = 1:this.numFrames
            meanDose(J) = this.holos(J).dose;
        end
    end
    
    % Plot a comparison of data values from several HoloStacks
    % depricated at present
    function compare(this,otherStacks,fieldName,displayType)
                
        %predefine unique colour/marker combinations for line plots
        MarkerColorPairs = {'o','r';'p','m';'d','k';'+','b';'*','g';'x','c'};
        
        figureHandle = this.display(fieldName,displayType);
        for curr=otherStacks
            %curr
            curr.display(fieldName,displayType,'',figureHandle);
        end
        %find all line plot objects in current axis
        lineObjs = findobj(gca,'Type','Line');
        
        %for each line object, set a unique color and marker
        set(lineObjs,{'Marker','Color'},MarkerColorPairs(1:length(lineObjs),:));
        
        legend({this.name,otherStacks.name});
        
        %Display title based on displayType
        switch lower(displayType)
            case 'error'
                title('Normalized RMS Error Comparison');
            case 'offsets'
                title('Offset Comparison');
            otherwise
                error('HoloStack:Compare unknown value for compareType');
        end
        
    end
    
     % This function takes the gain in e-/count, and pixelsize in nm and
     % find the cumulative radiation dose and plots it. Note that gain
     % calculation is a non-trival exercise.
    function findRadDose( this, pixelsize, gain )
       
        if( nargin < 3 )
            gain = 0.65; % 300 keV gain for US1000 on HF-3300
        end
        dose = this.getDose();
        
        % Generate a plotyy figure with e-/A^2 on one axis and C/cm^2 on
        % the other.
        
        % REMEMBER: THE MEAN DOSE SHOULD BE DIVIDED BY 2 TO ACCOUNT FOR THE
        % FACT THE REFERENCE HALF OF THE WAVE DOESN'T PASS THROUGH THE
        % SPECIMEN.  
        
        dose_eA2 = dose .* gain ./ (pixelsize.*10).^2; % convert to e-/A^2
        dose_Ccm2 = dose .* (1.602E-19 .* gain) ./ (pixelsize.*1E-7).^2; % convert to C/cm^2
        
        disp( [ 'Mean dose (e-/A^2) = ', num2str( mean(dose_eA2) ) ] );
        disp( [ 'Mean dose (C/cm^2) = ', num2str( mean(dose_Ccm2) ) ] );
        
        cumdose_eA2 = cumsum( dose_eA2 );
        cumdose_Ccm2 = cumsum( dose_Ccm2 );
        
        frameNum = 1:this.numFrames;
        
        fig = figure; movegui;
        set(fig,'DefaultAxesFontName','Times')
        set(fig,'DefaultAxesFontSize', 12)
        set(fig,'DefaultAxesFontWeight', 'Demi' );
        [ax,h1,h2] = plotyy( frameNum, cumdose_eA2, frameNum, cumdose_Ccm2 );
        set( h2, 'LineWidth', 2.5, 'Color', 'k' );
        xlabel( 'Frame number, m', 'FontSize', 16.0, 'FontWeight', 'Demi'  );
        set(get(ax(1),'Ylabel'),'String', 'Estimated Dose (e^-/A^2)', 'FontSize', 16.0, 'FontWeight', 'Demi') 
        set(get(ax(2),'Ylabel'),'String', 'Estimated Dose (C/cm^2)', 'FontSize', 16.0, 'FontWeight', 'Demi') 
        set(ax(1), 'Ylim', [0 max(cumdose_eA2)*1.15] )
        set(ax(2), 'Ylim', [0 max(cumdose_Ccm2)*1.15] )
        title( ['Estimated radiation dose: ', this.name] )
        % Force the same 
    end
    
    % Computes even-odd comparison of the hologram series to find the
    % experimental phase error.
    function computeEOPhaseErr( this, roi, roinames  )
        % roi should have the form [ x1, y1, x2, y2 ], can handle a matrix
        % of multiple coordinates (outputs multiple results).
        % i.e. roi = [ 1 2 3 4; 5 6 7 8];
        % Defaults to use the pmWindow as the ROI
        
        % Figure out ordering of holograms to strip out
        removeEven = this.ordering( iseven(this.ordering) );
        removeOdd = this.ordering( isodd(this.ordering) );
        
        % Generate childern objects
        HS_odd = this.copy( [this.name, ' - odd'] );
        HS_even = this.copy( [this.name, '- even'] );
        % Cull out even and odd frames, respectively
        HS_odd.removeHolo( removeEven );
        HS_even.removeHolo( removeOdd );
        
        % Generate index for even-odd
        frameIndex_eo = (2:2:this.numFrames).';
        if( ~exist( 'roi' ) || isempty( roi ) )
            % Compute across cross-correlation region
            Rescale_x = this.hp.holoSize(1)./this.hp.reconSize(1);
            Rescale_y = this.hp.holoSize(2)./this.hp.reconSize(2);
            roi = [ ceil(this.hp.pmWindow(1)./Rescale_x), ceil(this.hp.pmWindow(2)./Rescale_y), ...
                floor(this.hp.pmWindow(3)./Rescale_x), floor(this.hp.pmWindow(4)./Rescale_y) ];
        end
        nroi = size(roi,1);
        
        if( ~exist( 'roinames' ) || isempty( roi ) )
            roinames = cell( [nroi 1] );
            for I = 1:nroi
                roinames{I} = [ 'ROI #', num2str(I) ];
            end
        end
        
        
        pErr_reg = zeros( [numel(frameIndex_eo) nroi] ); % registered cumulative sideband
        pErr_sing = zeros( [numel(frameIndex_eo) nroi] ); % registered NON-cumulative sideband
        for J = 1:numel( HS_even.holos )
            % Compute the even-odd difference
            regtemp = angle( HS_even.holos(J).cumReg ./ HS_odd.holos(J).cumReg );
            singtemp = angle( HS_even.holos(J).regside ./ HS_odd.holos(J).regside );
            
            for I = 1:nroi
                pErr_reg(J,I) = std2( regtemp( roi(I,2):roi(I,4), roi(I,1):roi(I,3) )) ./ 2;
                pErr_sing(J,I) = std2( singtemp( roi(I,2):roi(I,4), roi(I,1):roi(I,3) )) ./ 2;
            end

        end
        
        smooth_pErr_reg = zeros( [numel(frameIndex_eo) nroi] );
        smooth_pErr_sing = zeros( [numel(frameIndex_eo) nroi] );
        for I = 1:nroi
            smooth_pErr_reg(:,I) = smooth( pErr_reg(:,I), 5 );
            smooth_pErr_sing(:,I) = smooth( pErr_sing(:,I), 5 );
        end
        
        % Plot the result with moving average
        plotcol = lines( nroi );
        fig = figure; movegui;
        hold on;
        set(gca, 'ColorOrder', min(plotcol + 0.3, 1) )
        plot( frameIndex_eo, pErr_sing, '.', ...
            frameIndex_eo, pErr_reg, '.', ...
            'MarkerSize', 15 );
        set(gca, 'ColorOrder', plotcol )
        set(gca, 'YScale', 'Log' );
        hleg = plot( frameIndex_eo, smooth_pErr_sing, '--', ...
            frameIndex_eo, smooth_pErr_reg, '-', ...
            'LineWidth', 2.5 );
        set(gca, 'YScale', 'Log' );
        hold off;
        axis tight;
        ylim( [0 0.1] );
        set( gca, 'FontName', 'Times', 'FontWeight', 'Demi', 'FontSize', 16 )
        xlabel( 'Frame number, m' );
        ylabel( 'RMS phase difference, \Delta\phi_{RMS} (rad)' );
        legend( hleg, roinames ,'Location', 'NorthEast' );
        
        % Output ultimate phase errors to the screen
        for I = 1:nroi
            disp( [ 'Ultimate phase error for ', roinames{I}, ': ', num2str( pErr_reg(end,I) ), ' rad (2pi/', num2str( 2.*pi./pErr_reg(end,I) ), ')' ] )
        end
    end
    

end %methods
end %classdef


function printRows(rows, label)
% print rows of data

if(~size(label))
    label = ' ';
end
[numrows,cols] = size(rows);

for j = 1:numrows;
    fprintf(1,'%10s : ',label(j,:));
    fprintf(1,'%10.2f',rows(j,:));
    fprintf(1,'\n');
end
end
